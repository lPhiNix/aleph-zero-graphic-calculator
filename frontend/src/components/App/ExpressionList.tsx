// src/components/App/ExpressionList.tsx
import { useEffect, useRef, useState } from 'react';
import styles from '../../styles/modules/expressionList.module.css';

interface ExpressionListProps {
    expressions: string[];
    onExpressionsChange: (updater: (prev: string[]) => string[]) => void;
    /** Se dispara cuando un <input> pierde el foco: √≠ndice + contenido */
    onExpressionBlur: (index: number, expr: string) => void;

    /** Arreglo de colores hex ("#rrggbb") por cada expresi√≥n */
    colors: string[];
    /** Callback que notifica al padre que la fila `index` cambi√≥ a `newColor` */
    onColorChange: (index: number, newColor: string) => void;

    /** Arreglo de flags indicando qu√© fila est√° deshabilitada */
    disabledFlags: boolean[];
    /** Callback para alternar (enable/disable) una fila dado su √≠ndice */
    onToggleDisabled: (index: number) => void;

    /** Arreglo de tipos de expresi√≥n devueltos por el backend (puede ser undefined) */
    expressionTypes: Array<string | undefined>;
}

export default function ExpressionList({
                                           expressions,
                                           onExpressionsChange,
                                           onExpressionBlur,
                                           colors,
                                           onColorChange,
                                           disabledFlags,
                                           onToggleDisabled,
                                           expressionTypes,
                                       }: ExpressionListProps) {
    const containerRef = useRef<HTMLDivElement>(null);
    const inputRefs = useRef<Array<HTMLInputElement | null>>([]);
    const colorInputRefs = useRef<Array<HTMLInputElement | null>>([]);

    // Para saber qu√© fila est√° enfocada y cu√°l est√° ‚Äúhovered‚Äù
    const [focusedIndex, setFocusedIndex] = useState<number | null>(null);
    const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);

    useEffect(() => {
        const el = containerRef.current;
        if (el) el.scrollTop = el.scrollHeight;
    }, [expressions]);

    const handleChange = (index: number, value: string) => {
        onExpressionsChange((prev) => {
            const updated = [...prev];
            updated[index] = value;

            // Si estamos en la √∫ltima fila y escribimos algo, a√±adimos una nueva vac√≠a
            if (index === prev.length - 1 && value.trim() !== '') {
                updated.push('');
            }
            return updated;
        });
    };

    const handleBlur = (index: number) => {
        const value = expressions[index] ?? '';
        onExpressionBlur(index, value);

        // Si estamos en la √∫ltima fila y qued√≥ con texto, a√±adimos otra vac√≠a
        const isLast = index === expressions.length - 1;
        if (!isLast) return;

        onExpressionsChange((prev) => {
            if (value.trim() !== '' && prev[prev.length - 1].trim() !== '') {
                return [...prev, ''];
            }
            return prev;
        });
    };

    const handleClearRow = (index: number) => {
        onExpressionsChange((prev) => {
            const updated = [...prev];
            updated[index] = '';
            return updated;
        });

        const inputEl = inputRefs.current[index];
        if (inputEl) {
            inputEl.focus();
            inputEl.select();
        }
    };

    const handleDeleteRow = (index: number) => {
        onExpressionsChange((prev) => {
            // Si s√≥lo queda una fila, mantenemos al menos una vac√≠a
            if (prev.length <= 1) return [''];
            const updated = [...prev];
            updated.splice(index, 1);
            return updated;
        });
    };

    // Antes de renderizar, reseteamos las referencias para sincronizar √≠ndices
    inputRefs.current = [];
    colorInputRefs.current = [];

    return (
        <div className={styles.listContainer} ref={containerRef}>
            {expressions.map((expr, idx) => {
                // Detectar si es la √∫ltima fila vac√≠a (placeholder)
                const isLastGap = idx === expressions.length - 1 && expr.trim() === '';

                // Determinar el tipo de etiqueta seg√∫n `expressionTypes[idx]`
                const tipo = expressionTypes[idx];
                let etiqueta: string;
                switch (tipo) {
                    case 'FUNCTION':
                        etiqueta = 'f';
                        break;
                    case 'ASSIGNMENT':
                        etiqueta = 'a';
                        break;
                    case 'NUMERIC':
                        etiqueta = 'N';
                        break;
                    case 'EQUATION':
                        etiqueta = 'Eq';
                        break;
                    case 'MATRIX':
                        etiqueta = 'm';
                        break;
                    case 'BOOLEAN':
                        etiqueta = 'b';
                        break;
                    default:
                        etiqueta = 'Ex';
                }

                // Color original de la funci√≥n (puede venir de padre)
                const originalColor = isLastGap ? '#666666' : colors[idx] || '#666666';
                // Si la fila est√° deshabilitada, forzamos gris
                const functionColor = disabledFlags[idx] ? '#666666' : originalColor;

                // Contar cu√°ntas veces apareci√≥ este mismo tipo antes de idx
                const countSameTypeBefore = expressionTypes
                    .slice(0, idx)
                    .filter((t) => t === tipo)
                    .length;
                // El n√∫mero que ponemos como sub√≠ndice es countSameTypeBefore + 1,
                // a menos que sea la √∫ltima fila vac√≠a (no mostramos sub√≠ndice).
                const subIndex = isLastGap ? '' : String(countSameTypeBefore + 1);

                return (
                    <div
                        key={idx}
                        className={`${styles.inputWrapper} ${
                            (hoveredIndex === idx || focusedIndex === idx) &&
                            !disabledFlags[idx]
                                ? styles.rowHighlighted
                                : ''
                        }`}
                        style={{
                            '--highlight-border': functionColor,
                        } as React.CSSProperties}
                        onMouseEnter={() => setHoveredIndex(idx)}
                        onMouseLeave={() =>
                            setHoveredIndex((prev) => (prev === idx ? null : prev))
                        }
                    >
                        {/* ‚îÄ‚îÄ‚îÄ CUADRADO ‚Äútipo·µ¢‚Äù A LA IZQUIERDA ‚îÄ‚îÄ‚îÄ */}
                        <div
                            className={styles.functionLabel}
                            style={{
                                backgroundColor: functionColor,
                                borderColor:
                                    (hoveredIndex === idx || focusedIndex === idx) &&
                                    !disabledFlags[idx]
                                        ? functionColor
                                        : 'transparent',
                                color: functionColor, // para que currentColor coincida
                                cursor: isLastGap ? 'default' : 'pointer', // √∫ltima fila no es clicable
                            }}
                            onClick={() => {
                                if (!isLastGap) {
                                    onToggleDisabled(idx);
                                }
                            }}
                        >
              <span className={styles.fLetter}>
                <em>{etiqueta}</em>
              </span>
                            {!isLastGap && (
                                <sub className={styles.fSubscript}>{subIndex}</sub>
                            )}
                        </div>

                        {/* ‚îÄ‚îÄ‚îÄ INPUT DE TEXTO ‚îÄ‚îÄ‚îÄ */}
                        <input
                            type="text"
                            className={styles.exprInput}
                            placeholder={isLastGap ? 'Escribir una funci√≥n' : ''}
                            value={expr}
                            ref={(el) => {
                                inputRefs.current[idx] = el;
                            }}
                            onChange={(e) => handleChange(idx, e.target.value)}
                            onFocus={() => setFocusedIndex(idx)}
                            onBlur={() => {
                                handleBlur(idx);
                                setFocusedIndex(null);
                            }}
                            aria-label={`Expresi√≥n ${idx + 1}`}
                        />

                        {/* ‚îÄ‚îÄ‚îÄ BOT√ìN ‚Äú√ó‚Äù (clear) s√≥lo si est√° enfocado y no vac√≠o ‚îÄ‚îÄ‚îÄ */}
                        {focusedIndex === idx && expr.trim() !== '' && (
                            <button
                                type="button"
                                aria-label={`Limpiar fila ${idx + 1}`}
                                className={styles.clearButton}
                                onMouseDown={(e) => {
                                    // Evitamos que el blur suceda antes de limpiar
                                    e.preventDefault();
                                    handleClearRow(idx);
                                }}
                            >
                                <span aria-hidden="true">√ó</span>
                            </button>
                        )}

                        {/*
              ‚îÄ‚îÄ‚îÄ LOS TRES ICON-BOTONES (‚ö° üé® üóëÔ∏è)
                  Solo si:
                    1) el rat√≥n est√° ‚Äúhover‚Äù sobre la fila
                    2) el input NO est√° enfocado
                    3) NO es la √∫ltima fila vac√≠a
              Dentro del contenedor, ocultamos ‚ö° si est√° deshabilitada la fila,
              pero mostramos üé® y üóëÔ∏è siempre.
            */}
                        {hoveredIndex === idx && focusedIndex !== idx && !isLastGap && (
                            <div className={styles.buttonsContainer}>
                                {/* 1) ‚ö° Evaluar ahora (no se muestra si est√° deshabilitada) */}
                                {!disabledFlags[idx] && (
                                    <button
                                        type="button"
                                        aria-label={`Evaluar fila ${idx + 1}`}
                                        className={styles.iconButton}
                                        style={{
                                            '--button-color': functionColor,
                                        } as React.CSSProperties}
                                        onMouseDown={(e) => {
                                            // Evitamos que el input pierda focus antes de evaluar
                                            e.preventDefault();
                                            onExpressionBlur(idx, expr);
                                        }}
                                    >
                                        <span className={styles.iconLightning}>‚ö°</span>
                                    </button>
                                )}

                                {/* 2) üé® Cambiar color (siempre se muestra) */}
                                <button
                                    type="button"
                                    aria-label={`Cambiar color fila ${idx + 1}`}
                                    className={styles.iconButton}
                                    style={{
                                        '--button-color': functionColor,
                                    } as React.CSSProperties}
                                    onClick={() => {
                                        const colorInput = colorInputRefs.current[idx];
                                        if (colorInput) colorInput.click();
                                    }}
                                >
                                    <span className={styles.iconPalette}>üé®</span>
                                </button>

                                {/* 3) üóëÔ∏è Borrar fila (siempre se muestra) */}
                                <button
                                    type="button"
                                    aria-label={`Borrar fila ${idx + 1}`}
                                    className={styles.iconButton}
                                    style={{
                                        '--button-color': functionColor,
                                    } as React.CSSProperties}
                                    onClick={(e) => {
                                        e.preventDefault();
                                        handleDeleteRow(idx);
                                    }}
                                >
                                    <span className={styles.iconTrash}>üóëÔ∏è</span>
                                </button>
                            </div>
                        )}

                        {/* ‚îÄ‚îÄ‚îÄ INPUT[type="color"] OCULTO PARA CADA FILA ‚îÄ‚îÄ‚îÄ */}
                        <input
                            type="color"
                            ref={(el) => {
                                colorInputRefs.current[idx] = el;
                            }}
                            value={functionColor}
                            onChange={(e) => {
                                onColorChange(idx, e.target.value);
                            }}
                            style={{
                                position: 'fixed',
                                width: '1px',
                                height: '1px',
                                opacity: 0,
                                pointerEvents: 'none',
                            }}
                        />
                    </div>
                );
            })}
        </div>
    );
}